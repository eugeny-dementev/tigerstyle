<!doctype html>
<html lang="RU">

<head>
  <meta charset="UTF-8" />
  <title>Tiger Style</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Tiger Style is a coding philosophy focused on safety, performance, and developer experience." />
  <meta name="author" content="Simon Klee" />
  <meta name="keywords"
    content="Tiger Style — это философия написания кода, сосредоточенная на безопасности, производительности и удобстве разработки" />

  <meta property="og:title" content="Tiger Style" />
  <meta property="og:description"
    content="A coding philosophy focused on safety, performance, and developer experience." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://tigerstyle.dev" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@simonkleee" />
  <meta name="twitter:title" content="Tiger Style" />
  <meta name="twitter:description"
    content="A coding philosophy focused on safety, performance, and developer experience." />

  <link rel="stylesheet" href="styles.css?v=0.1-dev" />
  <link rel="preload" href="./fonts/LiberationMono.woff2" as="font" type="font/woff2" crossorigin />
  <link rel="preload" href="./fonts/LiberationMono-Bold.woff2" as="font" type="font/woff2" crossorigin />
</head>

<body>
  <div class="container">
    <h1 class="title">Tiger Style</h1>
    <p class="version">Version 0.1-dev</p>

    <p>
      <strong>Tiger Style</strong> — это философия кодирования, сосредоточенная на
      <strong>безопасности</strong>, <strong>производительности</strong> и
      <strong>удобстве разработки</strong>. Вдохновленная практиками
      TigerBeetle, она направлена на создание надежного, эффективного и
      поддерживаемого программного обеспечения через дисциплинированный подход к
      инженерии.
    </p>

    <h3>Содержание</h3>
    <ol class="summary">
      <li><a href="#1-core-principles">Основные принципы</a></li>
      <li>
        <a href="#2-design-goals">Цели дизайна</a>
        <ol>
          <li><a href="#2.1-safety">Безопасность</a></li>
          <li><a href="#2.2-performance">Производительность</a></li>
          <li>
            <a href="#2.3-developer-experience">Удобство для разработчиков</a>
          </li>
        </ol>
      </li>
    </ol>
    <p class="supplementary">
      Дополнительные разделы: <a href="#addendum">Приложение</a>,
      <a href="#colophon">Заключение</a>
    </p>

    <h2 id="1-core-principles">1. Основные принципы</h2>
    <p>
      Tiger Style — это не просто набор стандартов кодирования; это практический
      подход к разработке программного обеспечения. Приоритеты на
      <strong>безопасность</strong>, <strong>производительность</strong> и
      <strong>удобство для разработчиков</strong> помогают создавать код, который
      надежен, эффективен и приятен в работе.
    </p>

    <h4 id="safety">Безопасность</h4>
    <p>
      Безопасность — это основа Tiger Style. Она подразумевает написание кода,
      который работает во всех ситуациях и минимизирует вероятность ошибок.
      Сосредоточенность на безопасности делает ваше программное обеспечение
      надежным и заслуживающим доверия.
    </p>

    <h4 id="performance">Производительность</h4>
    <p>
      Производительность — это эффективное использование ресурсов для создания
      быстрого, отзывчивого программного обеспечения. Приоритет производительности
      на ранних этапах помогает проектировать системы, которые оправдывают или
      превосходят ожидания пользователей.
    </p>

    <h4 id="developer-experience">Удобство для разработчиков</h4>
    <p>
      Хороший опыт разработчиков улучшает качество и удобство сопровождения кода.
      Читаемый и удобный для работы код способствует сотрудничеству и снижает
      количество ошибок, что приводит к более здоровой кодовой базе, которая
      выдерживает испытание временем
      <a href="#addendum-zero-technical-debt">[1]</a>.
    </p>

    <h3 id="2.1-safety">2.1. Безопасность</h3>

    <p>
      Безопасность в кодировании основывается на четких и структурированных подходах,
      которые предотвращают ошибки и укрепляют кодовую базу. Это означает написание
      кода, который работает во всех ситуациях и выявляет проблемы на ранних этапах.
      Сосредоточенность на безопасности позволяет создавать надежное программное
      обеспечение, которое предсказуемо работает в любой среде.
    </p>

    <h4 id="control-and-limits">Контроль и ограничения</h4>

    <p>
      Предсказуемый поток управления и ограниченные системные ресурсы важны для
      безопасного выполнения.
    </p>

    <ul>
      <li id="simple-and-explicit-control-flow">
        <p>
          <strong>Простой и явный поток управления</strong>: Предпочитайте
          простые конструкции управления сложной логике. Простая структура
          управления упрощает понимание кода и снижает риск ошибок. Избегайте
          рекурсии, если это возможно, чтобы обеспечить предсказуемость и избежать
          переполнения стека или неконтролируемого использования ресурсов.
        </p>
      </li>

      <li id="set-fixed-limits">
        <p>
          <strong>Установите фиксированные ограничения</strong>: Явно задавайте
          верхние границы для циклов, очередей и других структур данных.
          Фиксированные ограничения предотвращают бесконечные циклы и
          неконтролируемое использование ресурсов, придерживаясь принципа
          <strong>быстрой остановки</strong>. Такой подход позволяет быстро
          выявлять проблемы и поддерживать стабильность системы.
        </p>
      </li>

      <li id="limit-function-length">
        <p>
          <strong>Ограничьте длину функций</strong>: Держите функции короткими,
          желательно до <strong>70 строк</strong>. Более короткие функции легче
          понимать, тестировать и отлаживать. Это способствует принципу единственной
          ответственности, когда каждая функция выполняет одну задачу, что делает
          кодовую базу более модульной и удобной для сопровождения.
        </p>
      </li>

      <li id="centralize-control-flow">
        <p>
          <strong>Централизуйте поток управления</strong>: Размещайте операторы
          switch или if в основной функции-родителе, а неразветвляющуюся логику
          переносите в вспомогательные функции. Основная функция должна управлять
          состоянием, используя вспомогательные функции для вычислений без
          непосредственного их применения. Вспомогательные функции должны быть
          чистыми и сосредоточенными на конкретных вычислениях. Это разделяет
          ответственность: одна функция управляет потоком, другие обрабатывают
          конкретную логику.
        </p>
      </li>
    </ul>

    <h4 id="memory-and-types">Память и типы</h4>
    <p>
      Четкое и последовательное управление памятью и типами важно для написания
      безопасного и переносимого кода.
    </p>

    <ul>
      <li id="use-explicitly-sized-types">
        <p>
          <strong>Используйте типы с явным размером</strong>: Используйте типы данных
          с фиксированным размером, такие как <code>u32</code> или <code>i64</code>,
          вместо зависящих от архитектуры, например <code>usize</code>. Это обеспечивает
          предсказуемое поведение на всех платформах и избегает ошибок, связанных с
          размером, что улучшает переносимость и надежность.
        </p>
      </li>

      <li id="static-memory-allocation">
        <p>
          <strong>Статическое выделение памяти</strong>: Выделяйте всю необходимую память
          во время запуска и избегайте динамического выделения памяти после
          инициализации. Динамическое выделение памяти во время выполнения может
          вызывать непредсказуемое поведение, фрагментацию и утечки памяти. Статическое
          выделение упрощает управление памятью и делает его более предсказуемым.
        </p>
      </li>

      <li id="minimize-variable-scope">
        <p>
          <strong>Минимизируйте область видимости переменных</strong>: Объявляйте
          переменные в минимально возможной области видимости. Ограничение области
          видимости снижает риск непреднамеренных взаимодействий и неправильного
          использования. Это также улучшает читаемость кода и облегчает его
          сопровождение, удерживая переменные в контексте их использования.
        </p>
      </li>
    </ul>

    <h4 id="error-handling">Обработка ошибок</h4>

    <p>
      Правильная обработка ошибок поддерживает систему надежной и устойчивой в любых
      условиях.
    </p>

    <ul>
      <li id="use-assertions">
        <p>
          <strong>Используйте утверждения</strong>: Проверяйте выполнение условий в
          конкретных точках кода. Утверждения работают как внутренние проверки,
          повышают надежность и упрощают отладку.
        </p>
        <ul>
          <li>
            <strong>Проверяйте аргументы и возвращаемые значения функций</strong>:
            Убедитесь, что функции получают и возвращают ожидаемые значения.
          </li>
          <li>
            <strong>Сохраняйте инварианты</strong>: Поддерживайте стабильность
            критических условий, проверяя их во время выполнения.
          </li>
          <li>
            <strong>Используйте парные утверждения</strong>: Проверяйте важные данные
            в нескольких точках, чтобы вовремя выявлять несоответствия.
          </li>
          <li>
            <strong>Быстро завершайте выполнение при ошибках</strong>: Выявляйте
            неожиданные условия сразу, чтобы предотвратить продолжение выполнения
            с ошибками.
          </li>
        </ul>
      </li>

      <li id="handle-all-errors">
        <p>
          <strong>Обрабатывайте все ошибки</strong>: Проверяйте и обрабатывайте каждую
          ошибку. Игнорирование ошибок может привести к неопределенному поведению,
          проблемам с безопасностью или сбоям. Пишите тщательные тесты для кода,
          обрабатывающего ошибки, чтобы убедиться, что приложение работает корректно
          во всех случаях.
        </p>
      </li>

      <li id="treat-compiler-warnings-as-errors">
        <p>
          <strong>Рассматривайте предупреждения компилятора как ошибки</strong>:
          Используйте самые строгие настройки компилятора и
          <strong>рассматривайте все предупреждения как ошибки</strong>.
          Предупреждения часто указывают на потенциальные проблемы, которые могут
          стать причиной ошибок. Их исправление сразу улучшает качество и надежность кода.
        </p>
      </li>

      <li id="avoid-implicit-defaults">
        <p>
          <strong>Избегайте неявных значений по умолчанию</strong>: Явно указывайте
          параметры при вызове библиотечных функций, вместо того чтобы полагаться на
          значения по умолчанию. Неявные значения могут изменяться между версиями
          библиотек или в разных средах, что приводит к непредсказуемому поведению.
          Явная спецификация улучшает ясность и стабильность кода.
        </p>
      </li>
    </ul>

    <h3 id="2.2-performance">2.2. Производительность</h3>

    <p>
      Производительность заключается в эффективном использовании ресурсов для
      создания быстрого и отзывчивого программного обеспечения. Приоритизация
      производительности на ранних этапах помогает разрабатывать системы, которые
      соответствуют или превосходят ожидания пользователей без лишних затрат.
    </p>

    <h4 id="design-for-performance">Проектирование с учетом производительности</h4>

    <p>
      Ранние проектные решения оказывают значительное влияние на производительность.
      Тщательное планирование помогает избежать узких мест в будущем.
    </p>

    <ul>
      <li id="design-for-performance-early">
        <p>
          <strong>Учитывайте производительность на этапе проектирования</strong>:
          Рассматривайте производительность с самого начала разработки.
          Ранние архитектурные решения сильно влияют на общую производительность,
          а предварительное планирование позволяет избежать узких мест и
          повысить эффективность использования ресурсов.
        </p>
      </li>

      <li id="napkin-math">
        <p>
          <strong>Простые расчеты</strong>: Используйте быстрые "на коленке"
          расчеты для оценки производительности системы и затрат на ресурсы.
          Например, оцените, сколько времени потребуется для чтения 1 ГБ данных
          из памяти, или определите ожидаемые затраты на хранение логов при
          обработке 100,000 запросов в секунду. Это помогает установить
          реалистичные ожидания и выявить потенциальные узкие места на ранних этапах.
        </p>
      </li>

      <li id="batch-operations">
        <p>
          <strong>Пакетная обработка</strong>: Амортизируйте дорогостоящие операции,
          обрабатывая сразу несколько элементов. Пакетная обработка снижает накладные
          расходы на один элемент, увеличивает пропускную способность и особенно полезна
          для операций, связанных с вводом-выводом.
        </p>
      </li>
    </ul>

    <h4 id="efficient-resource-usage">Эффективное использование ресурсов</h4>
    <p>Сосредоточьтесь на оптимизации самых медленных ресурсов в следующем порядке:</p>
    <ol>
      <li>
        <strong>Сеть</strong>: Оптимизируйте передачу данных и уменьшайте задержки.
      </li>
      <li>
        <strong>Диск</strong>: Улучшайте операции ввода-вывода и эффективно управляйте
        хранилищем.
      </li>
      <li>
        <strong>Память</strong>: Используйте память рационально, избегайте утечек и
        избыточного использования.
      </li>
      <li>
        <strong>Процессор</strong>: Повышайте вычислительную эффективность и сокращайте
        время обработки.
      </li>
    </ol>

    <h4 id="predictability">Предсказуемость</h4>
    <p>
      Написание предсказуемого кода улучшает производительность за счет уменьшения
      промахов кэша процессора и оптимизации предсказания ветвлений.
    </p>

    <ul>
      <li id="ensure-predictability">
        <p>
          <strong>Обеспечьте предсказуемость</strong>: Пишите код с предсказуемыми
          путями выполнения. Предсказуемый код лучше использует кэширование процессора
          и предсказание ветвлений, что улучшает производительность. Избегайте
          шаблонов, которые вызывают частые промахи кэша или непредсказуемые ветвления,
          так как это ухудшает производительность.
        </p>
      </li>
      <li id="reduce-compiler-dependence">
        <p>
          <strong>Снизьте зависимость от компилятора</strong>: Не полагайтесь только на
          оптимизации компилятора для повышения производительности. Пишите понятный и
          эффективный код, не зависящий от поведения компилятора. Будьте явными в
          критически важных для производительности участках, чтобы обеспечить
          согласованность результатов на разных компиляторах.
        </p>
      </li>
    </ul>

    <h3 id="2.3-developer-experience">2.3. Опыт разработчика</h3>
    <p>
      Улучшение опыта разработчика создает более поддерживаемую и совместную кодовую базу.
    </p>

    <h4 id="name-things-meaningfully">Давайте понятные имена</h4>
    <p>
      Правильно подбирайте существительные и глаголы. Хорошие названия передают, что представляет собой объект или что
      он делает, создавая понятную и интуитивную модель. Это показывает понимание предметной области. Уделяйте время
      поиску хороших названий, где существительные и глаголы сочетаются, делая целое больше суммы его частей.
    </p>

    <ul>
      <li id="clear-and-consistent-naming">
        <p>
          <strong>Ясные и последовательные названия</strong>: Используйте описательные и значимые названия для
          переменных, функций и файлов. Хорошие названия улучшают читаемость кода и помогают другим понять назначение
          каждой компоненты. Соблюдайте единый стиль, например, <code>snake_case</code>, по всей кодовой базе.
        </p>
      </li>

      <li id="avoid-abbreviations">
        <p>
          <strong>Избегайте сокращений</strong>: Используйте полные слова в названиях, если только сокращение не
          является широко распространенным и понятным (например, <code>ID</code>, <code>URL</code>). Сокращения могут
          сбивать с толку и затруднять понимание кода, особенно для новых участников.
        </p>
      </li>

      <li id="include-units-or-qualifiers-in-names">
        <p>
          <strong>Добавляйте единицы измерения или уточняющие слова в названия</strong>: Дополняйте переменные единицами
          измерения или уточнениями, располагая их в порядке убывания значимости (например, <code>latency_ms_max</code>
          вместо <code>max_latency_ms</code>). Это устраняет неясность, предотвращает путаницу и помогает логично
          группировать связанные переменные, такие как <code>latency_ms_min</code>.
        </p>
      </li>

      <li id="document-the-why">
        <p>
          <strong>Документируйте "почему"</strong>: Используйте комментарии, чтобы объяснить, почему были приняты
          определенные решения, а не только что делает код. Понимание намерений помогает другим правильно поддерживать и
          расширять код. Предоставляйте контекст для сложных алгоритмов, необычных подходов или ключевых ограничений.
        </p>
      </li>

      <li id="use-proper-comment-style">
        <p>
          <strong>Используйте правильный стиль комментариев</strong>: Пишите комментарии в виде полных предложений с
          правильной пунктуацией и грамматикой. Четкие и профессиональные комментарии улучшают читаемость и
          демонстрируют внимание к деталям. Они помогают создавать более чистую и поддерживаемую кодовую базу.
        </p>
      </li>
    </ul>

    <h4 id="code-organization">Организуйте код</h4>
    <p>
      Хорошая организация кода облегчает его навигацию, поддержку и расширение. Логичная структура снижает когнитивную
      нагрузку, позволяя разработчикам сосредотачиваться на решении задач, а не на понимании кода. Группируйте связанные
      элементы и упрощайте интерфейсы, чтобы кодовая база оставалась чистой, масштабируемой и управляемой с ростом
      сложности.
    </p>

    <ul>
      <li id="organize-code-logically">
        <p>
          <strong>Организуйте код логично</strong>: Структурируйте код логически. Группируйте связанные функции и классы
          вместе. Располагайте код в естественном порядке, начиная с высокоуровневых абстракций перед деталями низкого
          уровня. Логичная организация облегчает навигацию и понимание кода.
        </p>
      </li>

      <li id="simplify-function-signatures">
        <p>
          <strong>Упрощайте сигнатуры функций</strong>: Держите интерфейсы функций простыми. Ограничивайте количество
          параметров и предпочитайте возвращать простые типы. Простые интерфейсы снижают когнитивную нагрузку, упрощая
          понимание и правильное использование функций.
        </p>
      </li>

      <li id="construct-objects-in-place">
        <p>
          <strong>Создавайте объекты на месте</strong>: Инициализируйте большие структуры или объекты непосредственно
          там, где они объявляются. Создание объектов на месте предотвращает ненужное копирование или перемещение
          данных, улучшая производительность и снижая вероятность ошибок жизненного цикла.
        </p>
      </li>

      <li id="minimize-variable-scope">
        <p>
          <strong>Минимизируйте область видимости переменных</strong>: Объявляйте переменные близко к месту их
          использования и в минимально необходимой области видимости. Это снижает риск неправильного использования и
          облегчает чтение и поддержку кода.
        </p>
      </li>
    </ul>

    <h4 id="ensure-consistency">Обеспечьте консистентность</h4>
    <p>
      Поддержание консистентности в коде помогает снизить количество ошибок и создает стабильную основу для всей
      системы.
    </p>

    <ul>
      <li id="avoid-duplicates-and-aliases">
        <p>
          <strong>Избегайте дублирования и псевдонимов</strong>: Предотвращайте несоответствия, избегая дублированных
          переменных или ненужных псевдонимов. Когда две переменные представляют одни и те же данные, увеличивается
          вероятность их рассогласования. Используйте ссылки или указатели, чтобы поддерживать единственный источник
          истины.
        </p>
      </li>

      <li id="pass-large-objects-by-reference">
        <p>
          <strong>Передавайте большие объекты по ссылке</strong>: Если аргумент функции больше 16 байт, передавайте его
          по ссылке вместо передачи по значению, чтобы избежать ненужного копирования. Это позволяет рано выявлять
          ошибки, связанные с непреднамеренным копированием.
        </p>
      </li>

      <li id="minimize-dimensionality">
        <p>
          <strong>Минимизируйте размерность</strong>: Сохраняйте сигнатуры функций и возвращаемые типы простыми, чтобы
          уменьшить количество случаев, которые разработчику нужно обработать. Например, предпочитайте <code>void</code>
          вместо <code>bool</code>, <code>bool</code> вместо <code>u64</code> и так далее, если это соответствует цели
          функции.
        </p>
      </li>

      <li id="handle-buffer-allocation-cleanly">
        <p>
          <strong>Аккуратно управляйте выделением буферов</strong>: При работе с буферами выделяйте их близко к месту
          использования и обеспечивайте выполнение всех связанных очисток в одном логическом блоке. Группируйте
          выделение и освобождение ресурсов с четким разделением, чтобы было проще выявить утечки.
        </p>
      </li>
    </ul>

    <h4 id="avoid-off-by-one-errors">Избегайте ошибок на единицу</h4>
    <p>
      Ошибки на единицу часто возникают из-за случайных взаимодействий между <code>index</code>, <code>count</code> или
      <code>size</code>. Рассматривайте их как отдельные типы и применяйте четкие правила при преобразовании между ними.
    </p>

    <ul>
      <li id="indexes-counts-sizes">
        <p>
          <strong>Индексы, количества и размеры</strong>: Индексы начинаются с 0, количества — с 1, а размеры
          представляют общий объем памяти. При преобразовании между ними добавляйте или умножайте соответствующим
          образом. Используйте значимые <a href="#include-units-or-qualifiers-in-names">названия с единицами измерения
            или уточнениями</a>, чтобы избежать путаницы.
        </p>
      </li>

      <li id="handle-division-intentionally">
        <p>
          <strong>Обрабатывайте деление осознанно</strong>: При делении четко указывайте намерение, уточняя, как следует
          обрабатывать округление в пограничных случаях. Используйте функции или операторы, предназначенные для точного
          деления, деления вниз или вверх. Это устраняет двусмысленность и обеспечивает предсказуемое поведение
          результата.
        </p>
      </li>
    </ul>

    <h4 id="code-consistency-and-tooling">Кодовая консистентность и инструменты</h4>
    <p>
      Консистентность в стиле кода и инструментах улучшает читаемость, снижает умственную нагрузку и упрощает совместную
      работу.
    </p>

    <ul>
      <li id="maintain-consistent-indentation">
        <p>
          <strong>Поддерживайте консистентный отступ</strong>: Используйте единый стиль отступов по всей кодовой базе.
          Например, использование 4 пробелов для отступов обеспечивает лучшую визуальную четкость, особенно в сложных
          структурах.
        </p>
      </li>

      <li id="limit-line-lengths">
        <p>
          <strong>Ограничивайте длину строк</strong>: Держите строки в пределах разумной длины (например, 100 символов),
          чтобы обеспечить читаемость. Это предотвращает горизонтальную прокрутку и помогает поддерживать доступный
          макет кода.
        </p>
      </li>

      <li id="use-clear-code-blocks">
        <p>
          <strong>Используйте четкие блоки кода</strong>: Структурируйте код, четко разделяя блоки (например,
          управляющие структуры, циклы, определения функций), чтобы их было легко понять. Избегайте размещения
          нескольких операторов в одной строке, даже если это разрешено. Последовательные структуры блоков предотвращают
          тонкие логические ошибки и упрощают поддержку кода.
        </p>
      </li>

      <li id="minimize-external-dependencies">
        <p>
          <strong>Минимизируйте внешние зависимости</strong>: Снижение количества внешних зависимостей упрощает процесс
          сборки и улучшает управление безопасностью. Меньшее количество зависимостей снижает риск атак на цепочку
          поставок, минимизирует проблемы с производительностью и ускоряет установку.
        </p>
      </li>

      <li id="standardize-tooling">
        <p>
          <strong>Стандартизируйте инструменты</strong>: Использование небольшого стандартизированного набора
          инструментов упрощает среду разработки и снижает случайную сложность. Выбирайте кроссплатформенные
          инструменты, где это возможно, чтобы избежать проблем, специфичных для платформ, и улучшить переносимость
          между системами.
        </p>
      </li>
    </ul>

    <hr class="section-divider" />

    <section id="addendum">
      <h2>Addendum</h2>

      <h3 id="addendum-zero-technical-debt">Addendum: Zero technical debt</h3>

      <p>
        While Tiger Style focuses on the core principles of safety,
        performance, and developer experience, these are reinforced by an
        underlying commitment to zero technical debt.
      </p>

      <p>
        A <strong>zero technical debt policy</strong> is key to maintaining a
        healthy codebase and ensuring long-term productivity. Addressing
        potential issues proactively and building robust solutions from the
        start helps avoid debt that would slow future development.
      </p>

      <ul>
        <li id="do-it-right-the-first-time">
          <p>
            <strong>Do it right the first time</strong>: Take the time to
            design and implement solutions correctly from the start. Rushed
            features lead to technical debt that requires costly refactoring
            later.
          </p>
        </li>

        <li id="be-proactive-in-problem-solving">
          <p>
            <strong>Be proactive in problem-solving</strong>: Anticipate
            potential issues and fix them before they escalate. Early
            detection saves time and resources, preventing performance
            bottlenecks and architectural flaws.
          </p>
        </li>

        <li id="build-momentum">
          <p>
            <strong>Build momentum</strong>: Delivering solid, reliable code
            builds confidence and enables faster development cycles.
            High-quality work supports innovation and reduces the need for
            future rewrites.
          </p>
        </li>
      </ul>

      <p>
        Avoiding technical debt ensures that progress is true progress—solid,
        reliable, and built to last.
      </p>

      <h3 id="addendum-performance-estimation">
        Addendum: Performance estimation
      </h3>

      <p>
        You should think about performance early in design. Napkin math is a
        helpful tool for this.
      </p>

      <p>
        Napkin math uses simple calculations and rounded numbers to quickly
        estimate system performance and resource needs.
      </p>

      <ul>
        <li>
          <strong>Quick insights</strong>: Understand system behavior fast
          without deep analysis.
        </li>
        <li>
          <strong>Early decisions</strong>: Find potential bottlenecks early
          in design.
        </li>
        <li>
          <strong>Sanity checks</strong>: See if an idea works before you
          build it.
        </li>
      </ul>

      <p>
        For example, if you're designing a system to store logs, you can
        estimate storage costs like this:
      </p>

      <pre>
        <code>
          1. <strong>Estimate log volume</strong>:
          Assume 1,000 requests per second (RPS)
          Each log entry is about 1 KB

          2. <strong>Calculate daily log volume</strong>:
          1,000 RPS * 86,400 seconds/day * 1 KB ≈ 86,400,000 KB/day ≈ 86.4 GB/day

          3. <strong>Estimate monthly storage</strong>:
          86.4 GB/day * 30 days ≈ 2,592 GB/month

          4. <strong>Estimate cost (using $0.02 per GB for blob storage)</strong>:
          2,592 GB * 1000 GB/TB * $0.02/GB ≈ $51 per month</code>
      </pre>

      <p>
        This gives you a rough idea of monthly storage costs. It helps you
        check if your logging plan works. The idea is to get within 10x of the
        right answer.
      </p>

      <p>
        For more, see
        <a href="https://github.com/sirupsen/napkin-math">Simon Eskildsen's napkin math project</a>.
      </p>
    </section>

    <hr class="section-divider" />

    <section id="colophon">
      <h2>Colophon</h2>

      <p>
        Этот текст это вольный перевод
        <a href="https://tigerstyle.dev">https://tigerstyle.dev</a>,
        который в свою очередь основан на идеях оригинального гайда
        <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md" target="_blank">
          Tiger Style
        </a>
        команды разработки TigerBeetle.
      </p>
      <ul class="no-bullets">
        <li>
          <strong>Автор перевода</strong>:
          <a href="https://github.com/eugeny-dementev">Eugeny Dementev</a>
        </li>
        <li><strong>Версия</strong>: 0.1-dev</li>
        <li><strong>Последнее обновление</strong>: December 2024</li>
        <li>
          <strong>Лицензия</strong>:
          <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
        </li>
        <li>
          <strong>GitHub Repo</strong>:
          <a href="https://github.com/eugeny-dementev/tigerstyle">
            https://github.com/eugeny-dementev/tigerstyle
          </a>
        </li>
        <li>
          <strong>Оригинальный текст</strong>:
          <a href="https://github.com/simonklee/tigerstyle">github.com/simonklee/tigerstyle</a>
        </li>
      </ul>
    </section>
  </div>
</body>

</html>
