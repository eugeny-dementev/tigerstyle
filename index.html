<!doctype html>
<html>

<head>
	<meta charset="UTF-8" />
	<title>Tiger Style</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="description"
		content="Tiger Style is a coding philosophy focused on safety, performance, and developer experience." />
	<meta name="author" content="Simon Klee" />
	<meta name="keywords"
		content="Tiger Style, coding philosophy, safety, performance, developer experience, TigerBeetle" />

	<meta property="og:title" content="Tiger Style" />
	<meta property="og:description"
		content="A coding philosophy focused on safety, performance, and developer experience." />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://tigerstyle.dev" />

	<meta name="twitter:card" content="summary" />
	<meta name="twitter:creator" content="@simonkleee" />
	<meta name="twitter:title" content="Tiger Style" />
	<meta name="twitter:description"
		content="A coding philosophy focused on safety, performance, and developer experience." />

	<link rel="stylesheet" href="styles.css?v=0.1-dev" />
	<link rel="preload" href="./fonts/LiberationMono.woff2" as="font" type="font/woff2" crossorigin />
	<link rel="preload" href="./fonts/LiberationMono-Bold.woff2" as="font" type="font/woff2" crossorigin />
</head>

<body>
	<div class="container">
		<h1 class="title">Tiger Style</h1>
		<p class="version">Version 0.1-dev</p>

		<p>
			<strong>Tiger Style</strong> is a coding philosophy focused on
			<strong>safety</strong>, <strong>performance</strong>, and
			<strong>developer experience</strong>. Inspired by the practices of
			TigerBeetle, it focuses on building robust, efficient, and maintainable
			software through disciplined engineering.
		</p>

		<h3>Summary</h3>
		<ol class="summary">
			<li><a href="#1-core-principles">Core principles</a></li>
			<li>
				<a href="#2-design-goals">Design goals</a>
				<ol>
					<li><a href="#2.1-safety">Safety</a></li>
					<li><a href="#2.2-performance">Performance</a></li>
					<li>
						<a href="#2.3-developer-experience">Developer experience</a>
					</li>
				</ol>
			</li>
		</ol>
		<p class="supplementary">
			Additional sections: <a href="#addendum">Addendum</a>,
			<a href="#colophon">Colophon</a>
		</p>

		<h2 id="1-core-principles">1. Core principles</h2>
		<p>
			Tiger Style is not just a set of coding standards; it's a practical
			approach to software development. By prioritizing
			<strong>safety</strong>, <strong>performance</strong>, and
			<strong>developer experience</strong>, you create code that is reliable,
			efficient, and enjoyable to work with.
		</p>

		<h4 id="safety">Safety</h4>
		<p>
			Safety is the foundation of Tiger Style. It means writing code that
			works in all situations and reduces the risk of errors. Focusing on
			safety makes your software reliable and trustworthy.
		</p>

		<h4 id="performance">Performance</h4>
		<p>
			Performance is about using resources efficiently to deliver fast,
			responsive software. Prioritizing performance early helps you design
			systems that meet or exceed user expectations.
		</p>

		<h4 id="developer-experience">Developer experience</h4>
		<p>
			A good developer experience improves code quality and maintainability.
			Readable and easy-to-work-with code encourages collaboration and reduces
			errors, leading to a healthier codebase that stands the test of time
			<a href="#addendum-zero-technical-debt">[1]</a>.
		</p>

		<h2 id="2-design-goals">2. Design goals</h2>

		<p>
			The design goals focus on building software that is safe, fast, and easy
			to maintain.
		</p>

		<h3 id="2.1-safety">2.1. Safety</h3>

		<p>
			Safety in coding relies on clear, structured practices that prevent
			errors and strengthen the codebase. It's about writing code that works
			in all situations and catches problems early. By focusing on safety, you
			create reliable software that behaves predictably no matter where it
			runs.
		</p>

		<h4 id="control-and-limits">Control and limits</h4>

		<p>
			Predictable control flow and bounded system resources are essential for
			safe execution.
		</p>

		<ul>
			<li id="simple-and-explicit-control-flow">
				<p>
					<strong>Simple and explicit control flow</strong>: Favor
					straightforward control structures over complex logic. Simple
					control flow makes code easier to understand and reduces the risk of
					bugs. Avoid recursion if possible to keep execution bounded and
					predictable, preventing stack overflows and uncontrolled resource
					use.
				</p>
			</li>

			<li id="set-fixed-limits">
				<p>
					<strong>Set fixed limits</strong>: Set explicit upper bounds on
					loops, queues, and other data structures. Fixed limits prevent
					infinite loops and uncontrolled resource use, following the
					<strong>fail-fast</strong> principle. This approach helps catch
					issues early and keeps the system stable.
				</p>
			</li>

			<li id="limit-function-length">
				<p>
					<strong>Limit function length</strong>: Keep functions concise,
					ideally under <strong>70 lines</strong>. Shorter functions are
					easier to understand, test, and debug. They promote single
					responsibility, where each function does one thing well, leading to
					a more modular and maintainable codebase.
				</p>
			</li>

			<li id="centralize-control-flow">
				<p>
					<strong>Centralize control flow</strong>: Keep switch or if
					statements in the main parent function, and move non-branching logic
					to helper functions. Let the parent function manage state, using
					helpers to calculate changes without directly applying them. Keep
					leaf functions pure and focused on specific computations. This
					divides responsibility: one function controls flow, others handle
					specific logic.
				</p>
			</li>
		</ul>

		<h4 id="memory-and-types">Memory and types</h4>
		<p>
			Clear and consistent handling of memory and types is key to writing
			safe, portable code.
		</p>

		<ul>
			<li id="use-explicitly-sized-types">
				<p>
					<strong>Use explicitly sized types</strong>: Use data types with
					explicit sizes, like <code>u32</code> or <code>i64</code>, instead
					of architecture-dependent types like <code>usize</code>. This keeps
					behavior consistent across platforms and avoids size-related errors,
					improving portability and reliability.
				</p>
			</li>

			<li id="static-memory-allocation">
				<p>
					<strong>Static memory allocation</strong>: Allocate all necessary
					memory during startup and avoid dynamic memory allocation after
					initialization. Dynamic allocation at runtime can cause
					unpredictable behavior, fragmentation, and memory leaks. Static
					allocation makes memory management simpler and more predictable.
				</p>
			</li>

			<li id="minimize-variable-scope">
				<p>
					<strong>Minimize variable scope</strong>: Declare variables in the
					smallest possible scope. Limiting scope reduces the risk of
					unintended interactions and misuse. It also makes the code more
					readable and easier to maintain by keeping variables within their
					relevant context.
				</p>
			</li>
		</ul>

		<h4 id="error-handling">Error handling</h4>

		<p>
			Correct error handling keeps the system robust and reliable in all
			conditions.
		</p>

		<ul>
			<li id="use-assertions">
				<p>
					<strong>Use assertions</strong>: Use assertions to verify that
					conditions hold true at specific points in the code. Assertions work
					as internal checks, increase robustness, and simplify debugging.
				</p>
				<ul>
					<li>
						<strong>Assert function arguments and return values</strong>:
						Check that functions receive and return expected values.
					</li>
					<li>
						<strong>Validate invariants</strong>: Keep critical conditions
						stable by asserting invariants during execution.
					</li>
					<li>
						<strong>Use pair assertions</strong>: Check critical data at
						multiple points to catch inconsistencies early.
					</li>
					<li>
						<strong>Fail fast on programmer errors</strong>: Detect unexpected
						conditions immediately, stopping faulty code from continuing.
					</li>
				</ul>
			</li>

			<li id="handle-all-errors">
				<p>
					<strong>Handle all errors</strong>: Check and handle every error.
					Ignoring errors can lead to undefined behavior, security issues, or
					crashes. Write thorough tests for error-handling code to make sure
					your application works correctly in all cases.
				</p>
			</li>

			<li id="treat-compiler-warnings-as-errors">
				<p>
					<strong>Treat compiler warnings as errors</strong>: Use the
					strictest compiler settings and
					<strong>treat all warnings as errors</strong>. Warnings often point
					to potential issues that could cause bugs. Fixing them right away
					improves code quality and reliability.
				</p>
			</li>

			<li id="avoid-implicit-defaults">
				<p>
					<strong>Avoid implicit defaults</strong>: Explicitly specify options
					when calling library functions instead of relying on defaults.
					Implicit defaults can change between library versions or across
					environments, causing inconsistent behavior. Being explicit improves
					code clarity and stability.
				</p>
			</li>
		</ul>

		<h3 id="2.2-performance">2.2. Performance</h3>

		<p>
			Performance is about using resources efficiently to deliver fast,
			responsive software. Prioritizing performance early helps design systems
			that meet or exceed user expectations without unnecessary overhead.
		</p>

		<h4 id="design-for-performance">Design for performance</h4>

		<p>
			Early design decisions have a significant impact on performance.
			Thoughtful planning helps avoid bottlenecks later.
		</p>

		<ul>
			<li id="design-for-performance-early">
				<p>
					<strong>Design for performance early</strong>: Consider performance
					during the initial design phase. Early architectural decisions have
					a big impact on overall performance, and planning ahead ensures you
					can avoid bottlenecks and improve resource efficiency.
				</p>
			</li>

			<li id="napkin-math">
				<p>
					<strong>Napkin math</strong>: Use quick, back-of-the-envelope
					calculations to estimate system performance and resource costs. For
					example, estimate how long it takes to read 1 GB of data from memory
					or what the expected storage cost will be for logging 100,000
					requests per second. This helps set practical expectations early and
					identify potential bottlenecks before they occur.
				</p>
			</li>

			<li id="batch-operations">
				<p>
					<strong>Batch operations</strong>: Amortize expensive operations by
					processing multiple items together. Batching reduces overhead per
					item, increases throughput, and is especially useful for I/O-bound
					operations.
				</p>
			</li>
		</ul>

		<h4 id="efficient-resource-usage">Efficient resource use</h4>
		<p>Focus on optimizing the slowest resources, typically in this order:</p>
		<ol>
			<li>
				<strong>Network</strong>: Optimize data transfer and reduce latency.
			</li>
			<li>
				<strong>Disk</strong>: Improve I/O operations and manage storage
				efficiently.
			</li>
			<li>
				<strong>Memory</strong>: Use memory effectively to prevent leaks and
				overuse.
			</li>
			<li>
				<strong>CPU</strong>: Increase computational efficiency and reduce
				processing time.
			</li>
		</ol>

		<h4 id="predictability">Predictability</h4>
		<p>
			Writing predictable code improves performance by reducing CPU cache
			misses and optimizing branch prediction.
		</p>

		<ul>
			<li id="ensure-predictability">
				<p>
					<strong>Ensure predictability</strong>: Write code with predictable
					execution paths. Predictable code uses CPU caching and branch
					prediction better, leading to improved performance. Avoid patterns
					that cause frequent cache misses or unpredictable branching, as they
					degrade performance.
				</p>
			</li>
			<li id="reduce-compiler-dependence">
				<p>
					<strong>Reduce compiler dependence</strong>: Don't rely solely on
					compiler optimizations for performance. Write clear, efficient code
					that doesn't depend on compiler behavior. Be explicit in
					performance-critical sections to ensure consistent results across
					compilers.
				</p>
			</li>
		</ul>

		<h3 id="2.3-developer-experience">2.3. Developer experience</h3>
		<p>
			Improving the developer experience creates a more maintainable and
			collaborative codebase.
		</p>

		<h4 id="name-things-meaningfully">Name things</h4>
		<p>
			Get the nouns and verbs right. Great names capture what something is or
			does and create a clear, intuitive model. They show you understand the
			domain. Take time to find good names, where nouns and verbs fit
			together, making the whole greater than the sum of its parts.
		</p>

		<ul>
			<li id="clear-and-consistent-naming">
				<p>
					<strong>Clear and consistent naming</strong>: Use descriptive and
					meaningful names for variables, functions, and files. Good naming
					improves code readability and helps others understand each
					component's purpose. Stick to a consistent style, like
					<code>snake_case</code>, throughout the codebase.
				</p>
			</li>

			<li id="avoid-abbreviations">
				<p>
					<strong>Avoid abbreviations</strong>: Use full words in names unless
					the abbreviation is widely accepted and clear (e.g.,
					<code>ID</code>, <code>URL</code>). Abbreviations can be confusing
					and make it harder for others, especially new contributors, to
					understand the code.
				</p>
			</li>

			<li id="include-units-or-qualifiers-in-names">
				<p>
					<strong>Include units or qualifiers in names</strong>: Append units
					or qualifiers to variable names, placing them in descending order of
					significance (e.g., <code>latency_ms_max</code> instead of
					<code>max_latency_ms</code>). This clears up meaning, avoids
					confusion, and ensures related variables, like
					<code>latency_ms_min</code>, line up logically and group together.
				</p>
			</li>

			<li id="document-the-why">
				<p>
					<strong>Document the 'why'</strong>: Use comments to explain why
					decisions were made, not just what the code does. Knowing the intent
					helps others maintain and extend the code properly. Give context for
					complex algorithms, unusual approaches, or key constraints.
				</p>
			</li>

			<li id="use-proper-comment-style">
				<p>
					<strong>Use proper comment style</strong>: Write comments as
					complete sentences with correct punctuation and grammar. Clear,
					professional comments improve readability and show attention to
					detail. They help create a cleaner, more maintainable codebase.
				</p>
			</li>
		</ul>

		<h4 id="code-organization">Organize things</h4>

		<p>
			Organizing code well makes it easy to navigate, maintain, and extend. A
			logical structure reduces cognitive load, letting developers focus on
			solving problems instead of figuring out the code. Group related
			elements, and simplify interfaces to keep the codebase clean, scalable,
			and manageable as complexity grows.
		</p>

		<ul>
			<li id="organize-code-logically">
				<p>
					<strong>Organize code logically</strong>: Structure your code
					logically. Group related functions and classes together. Order code
					naturally, placing high-level abstractions before low-level details.
					Logical organization makes code easier to navigate and understand.
				</p>
			</li>
			<li id="simplify-function-signatures">
				<p>
					<strong>Simplify function signatures</strong>: Keep function
					interfaces simple. Limit parameters, and prefer returning simple
					types. Simple interfaces reduce cognitive load, making functions
					easier to understand and use correctly.
				</p>
			</li>

			<li id="construct-objects-in-place">
				<p>
					<strong>Construct objects in-place</strong>: Initialize large
					structures or objects directly where they are declared. In-place
					construction avoids unnecessary copying or moving of data, improving
					performance and reducing the potential for lifecycle errors.
				</p>
			</li>

			<li id="minimize-variable-scope">
				<p>
					<strong>Minimize variable scope</strong>: Declare variables close to
					their usage and within the smallest necessary scope. This reduces
					the risk of misuse and makes code easier to read and maintain.
				</p>
			</li>
		</ul>

		<h4 id="ensure-consistency">Ensure consistency</h4>

		<p>
			Maintaining consistency in your code helps reduce errors and creates a
			stable foundation for the rest of the system.
		</p>

		<ul>
			<li id="avoid-duplicates-and-aliases">
				<p>
					<strong>Avoid duplicates and aliases</strong>: Prevent
					inconsistencies by avoiding duplicated variables or unnecessary
					aliases. When two variables represent the same data, there's a
					higher chance they fall out of sync. Use references or pointers to
					maintain a single source of truth.
				</p>
			</li>

			<li id="pass-large-objects-by-reference">
				<p>
					<strong>Pass large objects by reference</strong>: If a function's
					argument is larger than 16 bytes, pass it as a reference instead of
					by value to avoid unnecessary copying. This can catch bugs early
					where unintended copies may occur.
				</p>
			</li>

			<li id="minimize-dimensionality">
				<p>
					<strong>Minimize dimensionality</strong>: Keep function signatures
					and return types simple to reduce the number of cases a developer
					has to handle. For example, prefer <code>void</code> over
					<code>bool</code>, <code>bool</code> over <code>u64</code>, and so
					on, when it suits the function's purpose.
				</p>
			</li>

			<li id="handle-buffer-allocation-cleanly">
				<p>
					<strong>Handle buffer allocation cleanly</strong>: When working with
					buffers, allocate them close to where they are used and ensure all
					corresponding cleanup happens in the same logical block. Group
					resource allocation and deallocation with clear newlines to make
					leaks easier to identify.
				</p>
			</li>
		</ul>

		<h4 id="avoid-off-by-one-errors">Avoid off-by-one errors</h4>

		<p>
			Off-by-one errors often result from casual interactions between an
			<code>index</code>, a <code>count</code>, or a <code>size</code>. Treat
			these as distinct types, and apply clear rules when converting between
			them.
		</p>

		<ul>
			<li id="indexes-counts-sizes">
				<p>
					<strong>Indexes, counts, and sizes</strong>: Indexes are 0-based,
					counts are 1-based, and sizes represent total memory usage. When
					converting between them, add or multiply accordingly. Use meaningful
					<a href="#include-units-or-qualifiers-in-names">names with units or qualifiers</a>
					to avoid confusion. See
				</p>
			</li>

			<li id="handle-division-intentionally">
				<p>
					<strong>Handle division intentionally</strong>: When dividing, make
					your intent clear by specifying how rounding should be handled in
					edge cases. Use functions or operators designed for exact division,
					floor division, or ceiling division. This avoids ambiguity and
					ensures the result behaves as expected.
				</p>
			</li>
		</ul>

		<h4 id="code-consistency-and-tooling">Code consistency and tooling</h4>

		<p>
			Consistency in code style and tools improves readability, reduces mental
			load, and makes working together easier.
		</p>

		<ul>
			<li id="maintain-consistent-indentation">
				<p>
					<strong>Maintain consistent indentation</strong>: Use a uniform
					indentation style across the codebase. For example, using 4 spaces
					for indentation provides better visual clarity, especially in
					complex structures.
				</p>
			</li>

			<li id="limit-line-lengths">
				<p>
					<strong>Limit line lengths</strong>: Keep lines within a reasonable
					length (e.g., 100 characters) to ensure readability. This prevents
					horizontal scrolling and helps maintain an accessible code layout.
				</p>
			</li>

			<li id="use-clear-code-blocks">
				<p>
					<strong>Use clear code blocks</strong>: Structure code clearly by
					separating blocks (e.g., control structures, loops, function
					definitions) to make it easy to follow. Avoid placing multiple
					statements on a single line, even if allowed. Consistent block
					structures prevent subtle logic errors and make code easier to
					maintain.
				</p>
			</li>

			<li id="minimize-external-dependencies">
				<p>
					<strong>Minimize external dependencies</strong>: Reducing external
					dependencies simplifies the build process and improves security
					management. Fewer dependencies lower the risk of supply chain
					attacks, minimize performance issues, and speed up installation.
				</p>
			</li>

			<li id="standardize-tooling">
				<p>
					<strong>Standardize tooling</strong>: Using a small, standardized
					set of tools simplifies the development environment and reduces
					accidental complexity. Choose cross-platform tools where possible to
					avoid platform-specific issues and improve portability across
					systems.
				</p>
			</li>
		</ul>

		<hr class="section-divider" />

		<section id="addendum">
			<h2>Addendum</h2>

			<h3 id="addendum-zero-technical-debt">Addendum: Zero technical debt</h3>

			<p>
				While Tiger Style focuses on the core principles of safety,
				performance, and developer experience, these are reinforced by an
				underlying commitment to zero technical debt.
			</p>

			<p>
				A <strong>zero technical debt policy</strong> is key to maintaining a
				healthy codebase and ensuring long-term productivity. Addressing
				potential issues proactively and building robust solutions from the
				start helps avoid debt that would slow future development.
			</p>

			<ul>
				<li id="do-it-right-the-first-time">
					<p>
						<strong>Do it right the first time</strong>: Take the time to
						design and implement solutions correctly from the start. Rushed
						features lead to technical debt that requires costly refactoring
						later.
					</p>
				</li>

				<li id="be-proactive-in-problem-solving">
					<p>
						<strong>Be proactive in problem-solving</strong>: Anticipate
						potential issues and fix them before they escalate. Early
						detection saves time and resources, preventing performance
						bottlenecks and architectural flaws.
					</p>
				</li>

				<li id="build-momentum">
					<p>
						<strong>Build momentum</strong>: Delivering solid, reliable code
						builds confidence and enables faster development cycles.
						High-quality work supports innovation and reduces the need for
						future rewrites.
					</p>
				</li>
			</ul>

			<p>
				Avoiding technical debt ensures that progress is true progress—solid,
				reliable, and built to last.
			</p>

			<h3 id="addendum-performance-estimation">
				Addendum: Performance estimation
			</h3>

			<p>
				You should think about performance early in design. Napkin math is a
				helpful tool for this.
			</p>

			<p>
				Napkin math uses simple calculations and rounded numbers to quickly
				estimate system performance and resource needs.
			</p>

			<ul>
				<li>
					<strong>Quick insights</strong>: Understand system behavior fast
					without deep analysis.
				</li>
				<li>
					<strong>Early decisions</strong>: Find potential bottlenecks early
					in design.
				</li>
				<li>
					<strong>Sanity checks</strong>: See if an idea works before you
					build it.
				</li>
			</ul>

			<p>
				For example, if you're designing a system to store logs, you can
				estimate storage costs like this:
			</p>

			<pre>
				<code>
1. <strong>Estimate log volume</strong>:
   Assume 1,000 requests per second (RPS)
   Each log entry is about 1 KB

2. <strong>Calculate daily log volume</strong>:
   1,000 RPS * 86,400 seconds/day * 1 KB ≈ 86,400,000 KB/day ≈ 86.4 GB/day

3. <strong>Estimate monthly storage</strong>:
   86.4 GB/day * 30 days ≈ 2,592 GB/month

4. <strong>Estimate cost (using $0.02 per GB for blob storage)</strong>:
   2,592 GB * 1000 GB/TB * $0.02/GB ≈ $51 per month</code>
			</pre>

			<p>
				This gives you a rough idea of monthly storage costs. It helps you
				check if your logging plan works. The idea is to get within 10x of the
				right answer.
			</p>

			<p>
				For more, see
				<a href="https://github.com/sirupsen/napkin-math">Simon Eskildsen's napkin math project</a>.
			</p>
		</section>

		<hr class="section-divider" />

		<section id="colophon">
			<h2>Colophon</h2>

			<p>
				This document is a "remix" inspired by the original
				<a href="https://github.com/tigerbeetle/tigerbeetle/blob/ac75926f8868093b342ce2c64eac1e3001cf2301/docs/TIGER_STYLE.md"
					target="_blank">Tiger Style guide</a>
				from the TigerBeetle project. In the spirit of
				<a href="https://en.wikipedia.org/wiki/Remix_culture">Remix Culture</a>, parts of this document are verbatim
				copies of the original work,
				while other sections have been rewritten or adapted to fit the goals
				of this version. This remix builds upon the principles outlined in the
				original document with a more general approach.
			</p>
			<ul class="no-bullets">
				<li>
					<strong>Maintained by</strong>:
					<a href="https://simonklee.dk">Simon Klee</a>
				</li>
				<li><strong>Version</strong>: 0.1-dev</li>
				<li><strong>Last updated</strong>: October 2024</li>
				<li>
					<strong>License</strong>:
					<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
				</li>
				<li>
					<strong>Source</strong>:
					<a href="https://github.com/simonklee/tigerstyle">github.com/simonklee/tigerstyle</a>
				</li>
			</ul>
		</section>
	</div>
</body>

</html>
