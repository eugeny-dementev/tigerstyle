<!doctype html>
<html lang="RU">

<head>
  <meta charset="UTF-8" />
  <title>Tiger Style</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Tiger Style is a coding philosophy focused on safety, performance, and developer experience." />
  <meta name="author" content="Simon Klee" />
  <meta name="keywords"
    content="Tiger Style — это философия написания кода, сосредоточенная на безопасности, производительности и удобстве разработки" />

  <meta property="og:title" content="Tiger Style" />
  <meta property="og:description"
    content="A coding philosophy focused on safety, performance, and developer experience." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://tigerstyle.dev" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@simonkleee" />
  <meta name="twitter:title" content="Tiger Style" />
  <meta name="twitter:description"
    content="A coding philosophy focused on safety, performance, and developer experience." />

  <link rel="stylesheet" href="styles.css?v=0.1-dev" />
  <link rel="preload" href="./fonts/LiberationMono.woff2" as="font" type="font/woff2" crossorigin />
  <link rel="preload" href="./fonts/LiberationMono-Bold.woff2" as="font" type="font/woff2" crossorigin />
</head>

<body>
  <div class="container">
    <h1 class="title">Tiger Style</h1>
    <p class="version">Version 0.1-dev</p>

    <p>
      <strong>Tiger Style</strong> — это философия кодирования, сосредоточенная на
      <strong>безопасности</strong>, <strong>производительности</strong> и
      <strong>удобстве разработки</strong>. Вдохновленная практиками
      TigerBeetle, она направлена на создание надежного, эффективного и
      поддерживаемого программного обеспечения через дисциплинированный подход к
      инженерии.
    </p>

    <h3>Содержание</h3>
    <ol class="summary">
      <li><a href="#1-core-principles">Основные принципы</a></li>
      <li>
        <a href="#2-design-goals">Цели дизайна</a>
        <ol>
          <li><a href="#2.1-safety">Безопасность</a></li>
          <li><a href="#2.2-performance">Производительность</a></li>
          <li>
            <a href="#2.3-developer-experience">Удобство для разработчиков</a>
          </li>
        </ol>
      </li>
    </ol>
    <p class="supplementary">
      Дополнительные разделы: <a href="#addendum">Приложение</a>,
      <a href="#colophon">Заключение</a>
    </p>

    <h2 id="1-core-principles">1. Основные принципы</h2>
    <p>
      Tiger Style — это не просто набор стандартов кодирования; это практический
      подход к разработке программного обеспечения. Приоритеты на
      <strong>безопасность</strong>, <strong>производительность</strong> и
      <strong>удобство для разработчиков</strong> помогают создавать код, который
      надежен, эффективен и приятен в работе.
    </p>

    <h4 id="safety">Безопасность</h4>
    <p>
      Безопасность — это основа Tiger Style. Она подразумевает написание кода,
      который работает во всех ситуациях и минимизирует вероятность ошибок.
      Сосредоточенность на безопасности делает ваше программное обеспечение
      надежным и заслуживающим доверия.
    </p>

    <h4 id="performance">Производительность</h4>
    <p>
      Производительность — это эффективное использование ресурсов для создания
      быстрого, отзывчивого программного обеспечения. Приоритет производительности
      на ранних этапах помогает проектировать системы, которые оправдывают или
      превосходят ожидания пользователей.
    </p>

    <h4 id="developer-experience">Удобство для разработчиков</h4>
    <p>
      Хороший опыт разработчиков улучшает качество и удобство сопровождения кода.
      Читаемый и удобный для работы код способствует сотрудничеству и снижает
      количество ошибок, что приводит к более здоровой кодовой базе, которая
      выдерживает испытание временем
      <a href="#addendum-zero-technical-debt">[1]</a>.
    </p>

    <h3 id="2.1-safety">2.1. Безопасность</h3>

    <p>
      Безопасность в кодировании основывается на четких и структурированных подходах,
      которые предотвращают ошибки и укрепляют кодовую базу. Это означает написание
      кода, который работает во всех ситуациях и выявляет проблемы на ранних этапах.
      Сосредоточенность на безопасности позволяет создавать надежное программное
      обеспечение, которое предсказуемо работает в любой среде.
    </p>

    <h4 id="control-and-limits">Контроль и ограничения</h4>

    <p>
      Предсказуемый поток управления и ограниченные системные ресурсы важны для
      безопасного выполнения.
    </p>

    <ul>
      <li id="simple-and-explicit-control-flow">
        <p>
          <strong>Простой и явный поток управления</strong>: Предпочитайте
          простые конструкции управления сложной логике. Простая структура
          управления упрощает понимание кода и снижает риск ошибок. Избегайте
          рекурсии, если это возможно, чтобы обеспечить предсказуемость и избежать
          переполнения стека или неконтролируемого использования ресурсов.
        </p>
      </li>

      <li id="set-fixed-limits">
        <p>
          <strong>Установите фиксированные ограничения</strong>: Явно задавайте
          верхние границы для циклов, очередей и других структур данных.
          Фиксированные ограничения предотвращают бесконечные циклы и
          неконтролируемое использование ресурсов, придерживаясь принципа
          <strong>быстрой остановки</strong>. Такой подход позволяет быстро
          выявлять проблемы и поддерживать стабильность системы.
        </p>
      </li>

      <li id="limit-function-length">
        <p>
          <strong>Ограничьте длину функций</strong>: Держите функции короткими,
          желательно до <strong>70 строк</strong>. Более короткие функции легче
          понимать, тестировать и отлаживать. Это способствует принципу единственной
          ответственности, когда каждая функция выполняет одну задачу, что делает
          кодовую базу более модульной и удобной для сопровождения.
        </p>
      </li>

      <li id="centralize-control-flow">
        <p>
          <strong>Централизуйте поток управления</strong>: Размещайте операторы
          switch или if в основной функции-родителе, а неразветвляющуюся логику
          переносите в вспомогательные функции. Основная функция должна управлять
          состоянием, используя вспомогательные функции для вычислений без
          непосредственного их применения. Вспомогательные функции должны быть
          чистыми и сосредоточенными на конкретных вычислениях. Это разделяет
          ответственность: одна функция управляет потоком, другие обрабатывают
          конкретную логику.
        </p>
      </li>
    </ul>

    <h4 id="memory-and-types">Память и типы</h4>
    <p>
      Четкое и последовательное управление памятью и типами важно для написания
      безопасного и переносимого кода.
    </p>

    <ul>
      <li id="use-explicitly-sized-types">
        <p>
          <strong>Используйте типы с явным размером</strong>: Используйте типы данных
          с фиксированным размером, такие как <code>u32</code> или <code>i64</code>,
          вместо зависящих от архитектуры, например <code>usize</code>. Это обеспечивает
          предсказуемое поведение на всех платформах и избегает ошибок, связанных с
          размером, что улучшает переносимость и надежность.
        </p>
      </li>

      <li id="static-memory-allocation">
        <p>
          <strong>Статическое выделение памяти</strong>: Выделяйте всю необходимую память
          во время запуска и избегайте динамического выделения памяти после
          инициализации. Динамическое выделение памяти во время выполнения может
          вызывать непредсказуемое поведение, фрагментацию и утечки памяти. Статическое
          выделение упрощает управление памятью и делает его более предсказуемым.
        </p>
      </li>

      <li id="minimize-variable-scope">
        <p>
          <strong>Минимизируйте область видимости переменных</strong>: Объявляйте
          переменные в минимально возможной области видимости. Ограничение области
          видимости снижает риск непреднамеренных взаимодействий и неправильного
          использования. Это также улучшает читаемость кода и облегчает его
          сопровождение, удерживая переменные в контексте их использования.
        </p>
      </li>
    </ul>

    <h4 id="error-handling">Обработка ошибок</h4>

    <p>
      Правильная обработка ошибок поддерживает систему надежной и устойчивой в любых
      условиях.
    </p>

    <ul>
      <li id="use-assertions">
        <p>
          <strong>Используйте утверждения</strong>: Проверяйте выполнение условий в
          конкретных точках кода. Утверждения работают как внутренние проверки,
          повышают надежность и упрощают отладку.
        </p>
        <ul>
          <li>
            <strong>Проверяйте аргументы и возвращаемые значения функций</strong>:
            Убедитесь, что функции получают и возвращают ожидаемые значения.
          </li>
          <li>
            <strong>Сохраняйте инварианты</strong>: Поддерживайте стабильность
            критических условий, проверяя их во время выполнения.
          </li>
          <li>
            <strong>Используйте парные утверждения</strong>: Проверяйте важные данные
            в нескольких точках, чтобы вовремя выявлять несоответствия.
          </li>
          <li>
            <strong>Быстро завершайте выполнение при ошибках</strong>: Выявляйте
            неожиданные условия сразу, чтобы предотвратить продолжение выполнения
            с ошибками.
          </li>
        </ul>
      </li>

      <li id="handle-all-errors">
        <p>
          <strong>Обрабатывайте все ошибки</strong>: Проверяйте и обрабатывайте каждую
          ошибку. Игнорирование ошибок может привести к неопределенному поведению,
          проблемам с безопасностью или сбоям. Пишите тщательные тесты для кода,
          обрабатывающего ошибки, чтобы убедиться, что приложение работает корректно
          во всех случаях.
        </p>
      </li>

      <li id="treat-compiler-warnings-as-errors">
        <p>
          <strong>Рассматривайте предупреждения компилятора как ошибки</strong>:
          Используйте самые строгие настройки компилятора и
          <strong>рассматривайте все предупреждения как ошибки</strong>.
          Предупреждения часто указывают на потенциальные проблемы, которые могут
          стать причиной ошибок. Их исправление сразу улучшает качество и надежность кода.
        </p>
      </li>

      <li id="avoid-implicit-defaults">
        <p>
          <strong>Избегайте неявных значений по умолчанию</strong>: Явно указывайте
          параметры при вызове библиотечных функций, вместо того чтобы полагаться на
          значения по умолчанию. Неявные значения могут изменяться между версиями
          библиотек или в разных средах, что приводит к непредсказуемому поведению.
          Явная спецификация улучшает ясность и стабильность кода.
        </p>
      </li>
    </ul>

    <h3 id="2.2-performance">2.2. Производительность</h3>

    <p>
      Производительность заключается в эффективном использовании ресурсов для
      создания быстрого и отзывчивого программного обеспечения. Приоритизация
      производительности на ранних этапах помогает разрабатывать системы, которые
      соответствуют или превосходят ожидания пользователей без лишних затрат.
    </p>

    <h4 id="design-for-performance">Проектирование с учетом производительности</h4>

    <p>
      Ранние проектные решения оказывают значительное влияние на производительность.
      Тщательное планирование помогает избежать узких мест в будущем.
    </p>

    <ul>
      <li id="design-for-performance-early">
        <p>
          <strong>Учитывайте производительность на этапе проектирования</strong>:
          Рассматривайте производительность с самого начала разработки.
          Ранние архитектурные решения сильно влияют на общую производительность,
          а предварительное планирование позволяет избежать узких мест и
          повысить эффективность использования ресурсов.
        </p>
      </li>

      <li id="napkin-math">
        <p>
          <strong>Простые расчеты</strong>: Используйте быстрые "на коленке"
          расчеты для оценки производительности системы и затрат на ресурсы.
          Например, оцените, сколько времени потребуется для чтения 1 ГБ данных
          из памяти, или определите ожидаемые затраты на хранение логов при
          обработке 100,000 запросов в секунду. Это помогает установить
          реалистичные ожидания и выявить потенциальные узкие места на ранних этапах.
        </p>
      </li>

      <li id="batch-operations">
        <p>
          <strong>Пакетная обработка</strong>: Амортизируйте дорогостоящие операции,
          обрабатывая сразу несколько элементов. Пакетная обработка снижает накладные
          расходы на один элемент, увеличивает пропускную способность и особенно полезна
          для операций, связанных с вводом-выводом.
        </p>
      </li>
    </ul>

    <h4 id="efficient-resource-usage">Эффективное использование ресурсов</h4>
    <p>Сосредоточьтесь на оптимизации самых медленных ресурсов в следующем порядке:</p>
    <ol>
      <li>
        <strong>Сеть</strong>: Оптимизируйте передачу данных и уменьшайте задержки.
      </li>
      <li>
        <strong>Диск</strong>: Улучшайте операции ввода-вывода и эффективно управляйте
        хранилищем.
      </li>
      <li>
        <strong>Память</strong>: Используйте память рационально, избегайте утечек и
        избыточного использования.
      </li>
      <li>
        <strong>Процессор</strong>: Повышайте вычислительную эффективность и сокращайте
        время обработки.
      </li>
    </ol>

    <h4 id="predictability">Предсказуемость</h4>
    <p>
      Написание предсказуемого кода улучшает производительность за счет уменьшения
      промахов кэша процессора и оптимизации предсказания ветвлений.
    </p>

    <ul>
      <li id="ensure-predictability">
        <p>
          <strong>Обеспечьте предсказуемость</strong>: Пишите код с предсказуемыми
          путями выполнения. Предсказуемый код лучше использует кэширование процессора
          и предсказание ветвлений, что улучшает производительность. Избегайте
          шаблонов, которые вызывают частые промахи кэша или непредсказуемые ветвления,
          так как это ухудшает производительность.
        </p>
      </li>
      <li id="reduce-compiler-dependence">
        <p>
          <strong>Снизьте зависимость от компилятора</strong>: Не полагайтесь только на
          оптимизации компилятора для повышения производительности. Пишите понятный и
          эффективный код, не зависящий от поведения компилятора. Будьте явными в
          критически важных для производительности участках, чтобы обеспечить
          согласованность результатов на разных компиляторах.
        </p>
      </li>
    </ul>

    <h3 id="2.3-developer-experience">2.3. Developer experience</h3>
    <p>
      Improving the developer experience creates a more maintainable and
      collaborative codebase.
    </p>

    <h4 id="name-things-meaningfully">Name things</h4>
    <p>
      Get the nouns and verbs right. Great names capture what something is or
      does and create a clear, intuitive model. They show you understand the
      domain. Take time to find good names, where nouns and verbs fit
      together, making the whole greater than the sum of its parts.
    </p>

    <ul>
      <li id="clear-and-consistent-naming">
        <p>
          <strong>Clear and consistent naming</strong>: Use descriptive and
          meaningful names for variables, functions, and files. Good naming
          improves code readability and helps others understand each
          component's purpose. Stick to a consistent style, like
          <code>snake_case</code>, throughout the codebase.
        </p>
      </li>

      <li id="avoid-abbreviations">
        <p>
          <strong>Avoid abbreviations</strong>: Use full words in names unless
          the abbreviation is widely accepted and clear (e.g.,
          <code>ID</code>, <code>URL</code>). Abbreviations can be confusing
          and make it harder for others, especially new contributors, to
          understand the code.
        </p>
      </li>

      <li id="include-units-or-qualifiers-in-names">
        <p>
          <strong>Include units or qualifiers in names</strong>: Append units
          or qualifiers to variable names, placing them in descending order of
          significance (e.g., <code>latency_ms_max</code> instead of
          <code>max_latency_ms</code>). This clears up meaning, avoids
          confusion, and ensures related variables, like
          <code>latency_ms_min</code>, line up logically and group together.
        </p>
      </li>

      <li id="document-the-why">
        <p>
          <strong>Document the 'why'</strong>: Use comments to explain why
          decisions were made, not just what the code does. Knowing the intent
          helps others maintain and extend the code properly. Give context for
          complex algorithms, unusual approaches, or key constraints.
        </p>
      </li>

      <li id="use-proper-comment-style">
        <p>
          <strong>Use proper comment style</strong>: Write comments as
          complete sentences with correct punctuation and grammar. Clear,
          professional comments improve readability and show attention to
          detail. They help create a cleaner, more maintainable codebase.
        </p>
      </li>
    </ul>

    <h4 id="code-organization">Organize things</h4>

    <p>
      Organizing code well makes it easy to navigate, maintain, and extend. A
      logical structure reduces cognitive load, letting developers focus on
      solving problems instead of figuring out the code. Group related
      elements, and simplify interfaces to keep the codebase clean, scalable,
      and manageable as complexity grows.
    </p>

    <ul>
      <li id="organize-code-logically">
        <p>
          <strong>Organize code logically</strong>: Structure your code
          logically. Group related functions and classes together. Order code
          naturally, placing high-level abstractions before low-level details.
          Logical organization makes code easier to navigate and understand.
        </p>
      </li>
      <li id="simplify-function-signatures">
        <p>
          <strong>Simplify function signatures</strong>: Keep function
          interfaces simple. Limit parameters, and prefer returning simple
          types. Simple interfaces reduce cognitive load, making functions
          easier to understand and use correctly.
        </p>
      </li>

      <li id="construct-objects-in-place">
        <p>
          <strong>Construct objects in-place</strong>: Initialize large
          structures or objects directly where they are declared. In-place
          construction avoids unnecessary copying or moving of data, improving
          performance and reducing the potential for lifecycle errors.
        </p>
      </li>

      <li id="minimize-variable-scope">
        <p>
          <strong>Minimize variable scope</strong>: Declare variables close to
          their usage and within the smallest necessary scope. This reduces
          the risk of misuse and makes code easier to read and maintain.
        </p>
      </li>
    </ul>

    <h4 id="ensure-consistency">Ensure consistency</h4>

    <p>
      Maintaining consistency in your code helps reduce errors and creates a
      stable foundation for the rest of the system.
    </p>

    <ul>
      <li id="avoid-duplicates-and-aliases">
        <p>
          <strong>Avoid duplicates and aliases</strong>: Prevent
          inconsistencies by avoiding duplicated variables or unnecessary
          aliases. When two variables represent the same data, there's a
          higher chance they fall out of sync. Use references or pointers to
          maintain a single source of truth.
        </p>
      </li>

      <li id="pass-large-objects-by-reference">
        <p>
          <strong>Pass large objects by reference</strong>: If a function's
          argument is larger than 16 bytes, pass it as a reference instead of
          by value to avoid unnecessary copying. This can catch bugs early
          where unintended copies may occur.
        </p>
      </li>

      <li id="minimize-dimensionality">
        <p>
          <strong>Minimize dimensionality</strong>: Keep function signatures
          and return types simple to reduce the number of cases a developer
          has to handle. For example, prefer <code>void</code> over
          <code>bool</code>, <code>bool</code> over <code>u64</code>, and so
          on, when it suits the function's purpose.
        </p>
      </li>

      <li id="handle-buffer-allocation-cleanly">
        <p>
          <strong>Handle buffer allocation cleanly</strong>: When working with
          buffers, allocate them close to where they are used and ensure all
          corresponding cleanup happens in the same logical block. Group
          resource allocation and deallocation with clear newlines to make
          leaks easier to identify.
        </p>
      </li>
    </ul>

    <h4 id="avoid-off-by-one-errors">Avoid off-by-one errors</h4>

    <p>
      Off-by-one errors often result from casual interactions between an
      <code>index</code>, a <code>count</code>, or a <code>size</code>. Treat
      these as distinct types, and apply clear rules when converting between
      them.
    </p>

    <ul>
      <li id="indexes-counts-sizes">
        <p>
          <strong>Indexes, counts, and sizes</strong>: Indexes are 0-based,
          counts are 1-based, and sizes represent total memory usage. When
          converting between them, add or multiply accordingly. Use meaningful
          <a href="#include-units-or-qualifiers-in-names">names with units or qualifiers</a>
          to avoid confusion. See
        </p>
      </li>

      <li id="handle-division-intentionally">
        <p>
          <strong>Handle division intentionally</strong>: When dividing, make
          your intent clear by specifying how rounding should be handled in
          edge cases. Use functions or operators designed for exact division,
          floor division, or ceiling division. This avoids ambiguity and
          ensures the result behaves as expected.
        </p>
      </li>
    </ul>

    <h4 id="code-consistency-and-tooling">Code consistency and tooling</h4>

    <p>
      Consistency in code style and tools improves readability, reduces mental
      load, and makes working together easier.
    </p>

    <ul>
      <li id="maintain-consistent-indentation">
        <p>
          <strong>Maintain consistent indentation</strong>: Use a uniform
          indentation style across the codebase. For example, using 4 spaces
          for indentation provides better visual clarity, especially in
          complex structures.
        </p>
      </li>

      <li id="limit-line-lengths">
        <p>
          <strong>Limit line lengths</strong>: Keep lines within a reasonable
          length (e.g., 100 characters) to ensure readability. This prevents
          horizontal scrolling and helps maintain an accessible code layout.
        </p>
      </li>

      <li id="use-clear-code-blocks">
        <p>
          <strong>Use clear code blocks</strong>: Structure code clearly by
          separating blocks (e.g., control structures, loops, function
          definitions) to make it easy to follow. Avoid placing multiple
          statements on a single line, even if allowed. Consistent block
          structures prevent subtle logic errors and make code easier to
          maintain.
        </p>
      </li>

      <li id="minimize-external-dependencies">
        <p>
          <strong>Minimize external dependencies</strong>: Reducing external
          dependencies simplifies the build process and improves security
          management. Fewer dependencies lower the risk of supply chain
          attacks, minimize performance issues, and speed up installation.
        </p>
      </li>

      <li id="standardize-tooling">
        <p>
          <strong>Standardize tooling</strong>: Using a small, standardized
          set of tools simplifies the development environment and reduces
          accidental complexity. Choose cross-platform tools where possible to
          avoid platform-specific issues and improve portability across
          systems.
        </p>
      </li>
    </ul>

    <hr class="section-divider" />

    <section id="addendum">
      <h2>Addendum</h2>

      <h3 id="addendum-zero-technical-debt">Addendum: Zero technical debt</h3>

      <p>
        While Tiger Style focuses on the core principles of safety,
        performance, and developer experience, these are reinforced by an
        underlying commitment to zero technical debt.
      </p>

      <p>
        A <strong>zero technical debt policy</strong> is key to maintaining a
        healthy codebase and ensuring long-term productivity. Addressing
        potential issues proactively and building robust solutions from the
        start helps avoid debt that would slow future development.
      </p>

      <ul>
        <li id="do-it-right-the-first-time">
          <p>
            <strong>Do it right the first time</strong>: Take the time to
            design and implement solutions correctly from the start. Rushed
            features lead to technical debt that requires costly refactoring
            later.
          </p>
        </li>

        <li id="be-proactive-in-problem-solving">
          <p>
            <strong>Be proactive in problem-solving</strong>: Anticipate
            potential issues and fix them before they escalate. Early
            detection saves time and resources, preventing performance
            bottlenecks and architectural flaws.
          </p>
        </li>

        <li id="build-momentum">
          <p>
            <strong>Build momentum</strong>: Delivering solid, reliable code
            builds confidence and enables faster development cycles.
            High-quality work supports innovation and reduces the need for
            future rewrites.
          </p>
        </li>
      </ul>

      <p>
        Avoiding technical debt ensures that progress is true progress—solid,
        reliable, and built to last.
      </p>

      <h3 id="addendum-performance-estimation">
        Addendum: Performance estimation
      </h3>

      <p>
        You should think about performance early in design. Napkin math is a
        helpful tool for this.
      </p>

      <p>
        Napkin math uses simple calculations and rounded numbers to quickly
        estimate system performance and resource needs.
      </p>

      <ul>
        <li>
          <strong>Quick insights</strong>: Understand system behavior fast
          without deep analysis.
        </li>
        <li>
          <strong>Early decisions</strong>: Find potential bottlenecks early
          in design.
        </li>
        <li>
          <strong>Sanity checks</strong>: See if an idea works before you
          build it.
        </li>
      </ul>

      <p>
        For example, if you're designing a system to store logs, you can
        estimate storage costs like this:
      </p>

      <pre>
        <code>
          1. <strong>Estimate log volume</strong>:
          Assume 1,000 requests per second (RPS)
          Each log entry is about 1 KB

          2. <strong>Calculate daily log volume</strong>:
          1,000 RPS * 86,400 seconds/day * 1 KB ≈ 86,400,000 KB/day ≈ 86.4 GB/day

          3. <strong>Estimate monthly storage</strong>:
          86.4 GB/day * 30 days ≈ 2,592 GB/month

          4. <strong>Estimate cost (using $0.02 per GB for blob storage)</strong>:
          2,592 GB * 1000 GB/TB * $0.02/GB ≈ $51 per month</code>
      </pre>

      <p>
        This gives you a rough idea of monthly storage costs. It helps you
        check if your logging plan works. The idea is to get within 10x of the
        right answer.
      </p>

      <p>
        For more, see
        <a href="https://github.com/sirupsen/napkin-math">Simon Eskildsen's napkin math project</a>.
      </p>
    </section>

    <hr class="section-divider" />

    <section id="colophon">
      <h2>Colophon</h2>

      <p>
        Этот текст это вольный перевод
        <a href="https://tigerstyle.dev">https://tigerstyle.dev</a>,
        который в свою очередь основан на идеях оригинального гайда
        <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md" target="_blank">
          Tiger Style
        </a>
        команды разработки TigerBeetle.
      </p>
      <ul class="no-bullets">
        <li>
          <strong>Автор перевода</strong>:
          <a href="https://github.com/eugeny-dementev">Eugeny Dementev</a>
        </li>
        <li><strong>Версия</strong>: 0.1-dev</li>
        <li><strong>Последнее обновление</strong>: December 2024</li>
        <li>
          <strong>Лицензия</strong>:
          <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
        </li>
        <li>
          <strong>GitHub Repo</strong>:
          <a href="https://github.com/eugeny-dementev/tigerstyle">
            https://github.com/eugeny-dementev/tigerstyle
          </a>
        </li>
        <li>
          <strong>Оригинальный текст</strong>:
          <a href="https://github.com/simonklee/tigerstyle">github.com/simonklee/tigerstyle</a>
        </li>
      </ul>
    </section>
  </div>
</body>

</html>
